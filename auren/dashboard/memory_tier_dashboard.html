<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AUREN Intelligence Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow-x: hidden;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            background: #111111;
            border-right: 1px solid #222;
            padding: 20px;
            overflow-y: auto;
        }
        
        .logo {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #00ff88, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .metric-card {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid #333;
            transition: all 0.3s ease;
        }
        
        .metric-card:hover {
            border-color: #00ff88;
            transform: translateY(-2px);
        }
        
        .metric-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .metric-value {
            font-size: 28px;
            font-weight: bold;
            margin: 8px 0;
        }
        
        .metric-trend {
            font-size: 14px;
            color: #00ff88;
        }
        
        .metric-trend.down {
            color: #ff4444;
        }
        
        /* Main Content */
        .main-content {
            display: grid;
            grid-template-rows: auto 1fr;
            overflow: hidden;
        }
        
        .header {
            padding: 20px;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .view-selector {
            display: flex;
            gap: 10px;
        }
        
        .view-btn {
            padding: 8px 16px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .view-btn.active {
            background: #00ff88;
            color: #000;
            border-color: #00ff88;
        }
        
        /* Content Area */
        .content {
            padding: 20px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }
        
        /* Activity Feed */
        .activity-feed {
            background: #111;
            border-radius: 12px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .activity-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            border-bottom: 1px solid #222;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .agent-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .agent-avatar.neuroscientist { background: #ff6b6b; }
        .agent-avatar.training { background: #4ecdc4; }
        .agent-avatar.nutrition { background: #95e1d3; }
        .agent-avatar.recovery { background: #a8e6cf; }
        .agent-avatar.sleep { background: #7986cb; }
        .agent-avatar.memory_system { background: #9c88ff; }
        
        .activity-content {
            flex: 1;
        }
        
        .activity-type {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }
        
        .activity-detail {
            margin: 4px 0;
            font-size: 14px;
        }
        
        .activity-time {
            font-size: 12px;
            color: #666;
        }
        
        /* Memory Tier Widget */
        .memory-tier-widget {
            background: #111;
            border-radius: 12px;
            padding: 20px;
            min-height: 400px;
        }
        
        .memory-tier-charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .chart-container {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
        }
        
        .chart-title {
            font-size: 14px;
            color: #888;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .cache-effectiveness {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        }
        
        .effectiveness-value {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(45deg, #00ff88, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .tier-stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 20px;
        }
        
        .tier-stat-card {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            border: 1px solid #222;
            transition: all 0.3s ease;
        }
        
        .tier-stat-card:hover {
            border-color: #00ff88;
            transform: translateY(-2px);
        }
        
        .tier-name {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        
        .tier-metric {
            font-size: 24px;
            font-weight: bold;
            margin: 4px 0;
        }
        
        .tier-label {
            font-size: 11px;
            color: #666;
        }
        
        /* Optimization Suggestions */
        .optimization-suggestions {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            margin-top: 20px;
        }
        
        .suggestion-item {
            padding: 12px;
            border-left: 3px solid #00ff88;
            margin-bottom: 12px;
            background: rgba(0, 255, 136, 0.05);
        }
        
        .suggestion-text {
            font-size: 14px;
            margin-bottom: 4px;
        }
        
        .suggestion-impact {
            font-size: 12px;
            color: #00ff88;
        }
        
        /* Knowledge Access Heatmap */
        .knowledge-heatmap {
            background: #111;
            border-radius: 12px;
            padding: 20px;
        }
        
        .heatmap-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 4px;
            margin-top: 16px;
        }
        
        .heatmap-cell {
            aspect-ratio: 1;
            background: #1a1a1a;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            padding: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .heatmap-cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        
        .heatmap-cell.hot {
            background: #ff6b6b;
            color: #000;
        }
        
        .heatmap-cell.warm {
            background: #feca57;
            color: #000;
        }
        
        .heatmap-cell.cool {
            background: #48dbfb;
            color: #000;
        }
        
        /* Performance Widget */
        .performance-widget {
            background: #111;
            border-radius: 12px;
            padding: 20px;
        }
        
        .performance-overview {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .performance-card {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            border: 1px solid #333;
            transition: all 0.3s ease;
        }
        
        .performance-card:hover {
            border-color: #00ff88;
            transform: translateY(-2px);
        }
        
        .metric-suffix {
            font-size: 14px;
            color: #666;
            margin-top: 4px;
        }
        
        .circuit-state {
            font-size: 20px;
            font-weight: bold;
            margin: 8px 0;
            padding: 8px;
            border-radius: 6px;
        }
        
        .circuit-state.CLOSED {
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            border: 1px solid #00ff88;
        }
        
        .circuit-state.OPEN {
            background: rgba(255, 68, 68, 0.1);
            color: #ff4444;
            border: 1px solid #ff4444;
        }
        
        .circuit-state.HALF_OPEN {
            background: rgba(255, 204, 0, 0.1);
            color: #ffcc00;
            border: 1px solid #ffcc00;
        }
        
        .circuit-trips {
            font-size: 12px;
            color: #888;
        }
        
        .performance-charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .batch-metrics {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
            margin-top: 16px;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        
        .metric-name {
            color: #888;
            font-size: 14px;
        }
        
        .metric-val {
            color: #00ff88;
            font-weight: bold;
            font-size: 14px;
        }
        
        .latency-breakdown {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 20px;
        }
        
        .latency-bars {
            margin-top: 16px;
        }
        
        .latency-bar {
            display: grid;
            grid-template-columns: 50px 1fr 80px;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .latency-label {
            font-size: 14px;
            color: #888;
        }
        
        .latency-progress {
            background: #333;
            border-radius: 4px;
            height: 20px;
            overflow: hidden;
        }
        
        .latency-fill {
            height: 100%;
            transition: width 0.5s ease;
        }
        
        .latency-fill.avg {
            background: #00ff88;
        }
        
        .latency-fill.p95 {
            background: #0088ff;
        }
        
        .latency-fill.p99 {
            background: #ff6b6b;
        }
        
        .latency-value {
            font-size: 14px;
            font-weight: bold;
            text-align: right;
        }
        
        /* Real-time indicators */
        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #00ff88;
        }
        
        .live-dot {
            width: 8px;
            height: 8px;
            background: #00ff88;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="logo">AUREN Intelligence</div>
            
            <div class="metric-card">
                <div class="metric-label">Active Agents</div>
                <div class="metric-value" id="active-agents">6</div>
                <div class="metric-trend">All systems operational</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Tokens / Hour</div>
                <div class="metric-value" id="tokens-hour">18.2K</div>
                <div class="metric-trend down">↓ 5% from baseline</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Cost Today</div>
                <div class="metric-value" id="cost-today">$12.45</div>
                <div class="metric-trend">On budget</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Knowledge Accesses</div>
                <div class="metric-value" id="knowledge-accesses">342</div>
                <div class="metric-trend">↑ 15% from yesterday</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Avg Response Time</div>
                <div class="metric-value" id="response-time">1.8s</div>
                <div class="metric-trend">Below 2s target</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Cache Effectiveness</div>
                <div class="metric-value" id="cache-effectiveness">72%</div>
                <div class="metric-trend">↑ 3% improvement</div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <div class="header">
                <h1>Real-Time Agent Monitoring</h1>
                <div class="view-selector">
                    <button class="view-btn active" onclick="switchView('activity')">Activity Feed</button>
                    <button class="view-btn" onclick="switchView('memory')">Memory Tiers</button>
                    <button class="view-btn" onclick="switchView('performance')">Performance</button>
                    <button class="view-btn" onclick="switchView('knowledge')">Knowledge Access</button>
                    <button class="view-btn" onclick="switchView('economics')">Token Economics</button>
                    <button class="view-btn" onclick="switchView('collaboration')">Collaboration</button>
                </div>
                <div class="live-indicator">
                    <span class="live-dot"></span>
                    <span>LIVE</span>
                </div>
            </div>
            
            <div class="content" id="main-content">
                <!-- Activity Feed View -->
                <div class="activity-feed" id="activity-view">
                    <h3>Agent Activity Feed</h3>
                    <div id="activity-items">
                        <!-- Real-time activities will be inserted here -->
                    </div>
                </div>
                
                <!-- Memory Tier Widget -->
                <div class="memory-tier-widget" id="memory-view" style="display: none;">
                    <h3>Memory Tier Performance</h3>
                    
                    <div class="memory-tier-charts">
                        <div class="chart-container">
                            <div class="chart-title">Tier Hit Rates</div>
                            <canvas id="tier-hit-chart" width="200" height="200"></canvas>
                        </div>
                        <div class="chart-container">
                            <div class="chart-title">Latency Comparison (ms)</div>
                            <canvas id="tier-latency-chart" width="200" height="200"></canvas>
                        </div>
                    </div>
                    
                    <div class="cache-effectiveness">
                        <div class="metric-label">Overall Cache Effectiveness</div>
                        <div class="effectiveness-value" id="cache-eff-value">72%</div>
                        <div class="metric-trend">Redis serving majority of requests</div>
                    </div>
                    
                    <div class="tier-stats-grid">
                        <div class="tier-stat-card">
                            <div class="tier-name">Redis (L1)</div>
                            <div class="tier-metric" id="redis-hit-rate">45%</div>
                            <div class="tier-label">Hit Rate</div>
                            <div class="tier-metric" id="redis-latency">5ms</div>
                            <div class="tier-label">Avg Latency</div>
                        </div>
                        <div class="tier-stat-card">
                            <div class="tier-name">PostgreSQL (L2)</div>
                            <div class="tier-metric" id="pg-hit-rate">40%</div>
                            <div class="tier-label">Hit Rate</div>
                            <div class="tier-metric" id="pg-latency">25ms</div>
                            <div class="tier-label">Avg Latency</div>
                        </div>
                        <div class="tier-stat-card">
                            <div class="tier-name">ChromaDB (L3)</div>
                            <div class="tier-metric" id="chroma-hit-rate">15%</div>
                            <div class="tier-label">Hit Rate</div>
                            <div class="tier-metric" id="chroma-latency">150ms</div>
                            <div class="tier-label">Avg Latency</div>
                        </div>
                    </div>
                    
                    <div class="optimization-suggestions">
                        <h4>Optimization Suggestions</h4>
                        <div id="optimization-list">
                            <!-- Suggestions will be inserted here -->
                        </div>
                    </div>
                </div>
                
                <!-- Performance Optimizer Widget -->
                <div class="performance-widget" id="performance-view" style="display: none;">
                    <h3>Performance Optimization</h3>
                    
                    <div class="performance-overview">
                        <div class="performance-card">
                            <div class="metric-label">Throughput</div>
                            <div class="metric-value" id="throughput-value">0</div>
                            <div class="metric-suffix">events/sec</div>
                        </div>
                        <div class="performance-card">
                            <div class="metric-label">Batching Efficiency</div>
                            <div class="metric-value" id="batch-efficiency">0%</div>
                            <div class="metric-trend">Target: 80%+</div>
                        </div>
                        <div class="performance-card circuit-status">
                            <div class="metric-label">Circuit Breaker</div>
                            <div class="circuit-state" id="circuit-state">CLOSED</div>
                            <div class="circuit-trips" id="circuit-trips">0 trips</div>
                        </div>
                    </div>
                    
                    <div class="performance-charts">
                        <div class="chart-container">
                            <div class="chart-title">Batch Size Distribution</div>
                            <canvas id="batch-size-chart" width="300" height="200"></canvas>
                        </div>
                        <div class="chart-container">
                            <div class="chart-title">Latency Percentiles</div>
                            <canvas id="latency-chart" width="300" height="200"></canvas>
                        </div>
                    </div>
                    
                    <div class="batch-metrics">
                        <h4>Batching Metrics</h4>
                        <div class="metrics-grid">
                            <div class="metric-item">
                                <span class="metric-name">Current Batch:</span>
                                <span class="metric-val" id="current-batch-size">0</span> events
                            </div>
                            <div class="metric-item">
                                <span class="metric-name">Total Batches:</span>
                                <span class="metric-val" id="total-batches">0</span>
                            </div>
                            <div class="metric-item">
                                <span class="metric-name">Avg Batch Size:</span>
                                <span class="metric-val" id="avg-batch-size">0</span>
                            </div>
                            <div class="metric-item">
                                <span class="metric-name">Drop Rate:</span>
                                <span class="metric-val" id="drop-rate">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="latency-breakdown">
                        <h4>Latency Breakdown</h4>
                        <div class="latency-bars">
                            <div class="latency-bar">
                                <div class="latency-label">Avg</div>
                                <div class="latency-progress">
                                    <div class="latency-fill avg" id="avg-latency-bar" style="width: 0%"></div>
                                </div>
                                <div class="latency-value" id="avg-latency">0ms</div>
                            </div>
                            <div class="latency-bar">
                                <div class="latency-label">P95</div>
                                <div class="latency-progress">
                                    <div class="latency-fill p95" id="p95-latency-bar" style="width: 0%"></div>
                                </div>
                                <div class="latency-value" id="p95-latency">0ms</div>
                            </div>
                            <div class="latency-bar">
                                <div class="latency-label">P99</div>
                                <div class="latency-progress">
                                    <div class="latency-fill p99" id="p99-latency-bar" style="width: 0%"></div>
                                </div>
                                <div class="latency-value" id="p99-latency">0ms</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Knowledge Access Heatmap -->
                <div class="knowledge-heatmap" id="knowledge-view" style="display: none;">
                    <h3>Knowledge Access Patterns</h3>
                    <div class="heatmap-grid" id="knowledge-grid">
                        <!-- Knowledge items will be inserted here -->
                    </div>
                </div>
                
                <!-- Token Economics View -->
                <div class="token-tracker" id="economics-view" style="display: none;">
                    <h3>Token Usage & Costs</h3>
                    <div class="token-bar">
                        <div class="token-fill" id="token-fill" style="width: 65%;">
                            65% of daily budget
                        </div>
                    </div>
                    <div class="agent-costs" id="agent-costs">
                        <!-- Agent costs will be inserted here -->
                    </div>
                </div>
                
                <!-- Collaboration Graph -->
                <div class="collaboration-graph" id="collaboration-view" style="display: none;">
                    <h3>Agent Collaboration Network</h3>
                    <canvas id="collaboration-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // WebSocket connection for real-time updates
        let ws = null;
        let activityBuffer = [];
        let knowledgeAccess = {};
        let agentCosts = {};
        let memoryTierStats = {
            redis: { hits: 45, accesses: 100, latency: 5 },
            postgresql: { hits: 40, accesses: 100, latency: 25 },
            chromadb: { hits: 15, accesses: 100, latency: 150 }
        };
        
        // Chart instances
        let tierHitChart = null;
        let tierLatencyChart = null;
        let batchSizeChart = null;
        let latencyPercentilesChart = null;
        
        // Performance metrics
        let performanceMetrics = {
            throughput: 0,
            batchingEfficiency: 0,
            circuitState: 'closed',
            currentBatchSize: 0,
            totalBatches: 0,
            avgBatchSize: 0,
            dropRate: 0,
            avgLatency: 0,
            p95Latency: 0,
            p99Latency: 0
        };
        
        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8765/ws/dashboard');
            
            ws.onopen = () => {
                console.log('Connected to AUREN monitoring');
                // Send authentication
                ws.send(JSON.stringify({
                    token: 'your-auth-token',
                    agent_filter: [],
                    performance_threshold: 0.0,
                    subscriptions: ['all_events']
                }));
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleRealtimeEvent(data);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(connectWebSocket, 3000);
            };
        }
        
        function handleRealtimeEvent(data) {
            if (data.type === 'stream_event') {
                const event = data.event;
                
                // Update activity feed
                if (event.event_type.includes('agent_')) {
                    addActivityItem(event);
                }
                
                // Update memory tier tracking
                if (event.event_type === 'memory_tier_access') {
                    updateMemoryTierMetrics(event);
                }
                
                // Update knowledge access
                if (event.event_type === 'knowledge_access') {
                    updateKnowledgeAccess(event);
                }
                
                // Update token usage
                if (event.event_type === 'llm_call' || event.event_type === 'tool_usage') {
                    updateTokenUsage(event);
                }
                
                // Update collaboration graph
                if (event.event_type === 'agent_collaboration') {
                    updateCollaborationGraph(event);
                }
                
                // Update sidebar metrics
                updateMetrics(event);
            }
            
            // Handle performance metrics updates
            if (data.type === 'performance_metrics') {
                updatePerformanceMetrics(data.data);
            }
        }
        
        function addActivityItem(event) {
            const container = document.getElementById('activity-items');
            const item = document.createElement('div');
            item.className = 'activity-item';
            
            const agentName = event.source_agent?.id || 'system';
            const agentInitial = agentName.charAt(0).toUpperCase();
            
            item.innerHTML = `
                <div class="agent-avatar ${agentName}">${agentInitial}</div>
                <div class="activity-content">
                    <div class="activity-type">${event.event_type.replace(/_/g, ' ')}</div>
                    <div class="activity-detail">${getEventDetail(event)}</div>
                    <div class="activity-time">${new Date(event.timestamp).toLocaleTimeString()}</div>
                </div>
            `;
            
            container.insertBefore(item, container.firstChild);
            
            // Keep only last 50 items
            while (container.children.length > 50) {
                container.removeChild(container.lastChild);
            }
        }
        
        function getEventDetail(event) {
            switch(event.event_type) {
                case 'agent_execution_started':
                    return `${event.source_agent.id} analyzing user query`;
                case 'agent_collaboration':
                    return `Collaborating with ${event.payload.collaborating_agents.join(', ')}`;
                case 'hypothesis_formation':
                    return `Formed hypothesis: "${event.payload.description}"`;
                case 'knowledge_access':
                    return `Accessed ${event.payload.items_retrieved} knowledge items`;
                case 'tool_usage':
                    return `Used ${event.payload.tool_name} (${event.payload.tokens_used} tokens)`;
                case 'memory_tier_access':
                    return `Memory accessed from ${event.payload.tier_accessed} (${event.payload.total_latency_ms.toFixed(1)}ms)`;
                default:
                    return 'Processing...';
            }
        }
        
        function updateMemoryTierMetrics(event) {
            const payload = event.payload;
            const tierAccessed = payload.tier_accessed;
            
            // Update tier statistics
            if (payload.tier_latencies) {
                Object.entries(payload.tier_latencies).forEach(([tier, data]) => {
                    if (!memoryTierStats[tier]) {
                        memoryTierStats[tier] = { hits: 0, accesses: 0, latency: 0 };
                    }
                    
                    memoryTierStats[tier].accesses++;
                    if (data.hit) {
                        memoryTierStats[tier].hits++;
                    }
                    
                    // Update rolling average latency
                    const currentLatency = memoryTierStats[tier].latency;
                    memoryTierStats[tier].latency = (currentLatency * 0.9 + data.latency_ms * 0.1);
                });
            }
            
            // Update cache effectiveness
            updateCacheEffectiveness();
            
            // Update charts if memory view is active
            if (document.getElementById('memory-view').style.display !== 'none') {
                updateMemoryCharts();
            }
            
            // Add optimization suggestions if any
            if (payload.optimization_suggestions) {
                updateOptimizationSuggestions(payload.optimization_suggestions);
            }
        }
        
        function updateCacheEffectiveness() {
            const redisHits = memoryTierStats.redis.hits;
            const totalAccesses = Object.values(memoryTierStats).reduce((sum, tier) => sum + tier.accesses, 0);
            const effectiveness = totalAccesses > 0 ? (redisHits / totalAccesses * 100) : 0;
            
            document.getElementById('cache-effectiveness').textContent = `${effectiveness.toFixed(0)}%`;
            document.getElementById('cache-eff-value').textContent = `${effectiveness.toFixed(0)}%`;
        }
        
        function initializeMemoryCharts() {
            // Initialize Tier Hit Rate Pie Chart
            const hitCtx = document.getElementById('tier-hit-chart').getContext('2d');
            tierHitChart = new Chart(hitCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Redis', 'PostgreSQL', 'ChromaDB'],
                    datasets: [{
                        data: [45, 40, 15],
                        backgroundColor: ['#00ff88', '#0088ff', '#ff6b6b'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#fff',
                                padding: 10
                            }
                        }
                    }
                }
            });
            
            // Initialize Latency Comparison Bar Chart
            const latencyCtx = document.getElementById('tier-latency-chart').getContext('2d');
            tierLatencyChart = new Chart(latencyCtx, {
                type: 'bar',
                data: {
                    labels: ['Redis', 'PostgreSQL', 'ChromaDB'],
                    datasets: [{
                        label: 'Latency (ms)',
                        data: [5, 25, 150],
                        backgroundColor: ['#00ff88', '#0088ff', '#ff6b6b']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: '#333'
                            },
                            ticks: {
                                color: '#fff'
                            }
                        },
                        x: {
                            grid: {
                                color: '#333'
                            },
                            ticks: {
                                color: '#fff'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }
        
        function updateMemoryCharts() {
            // Update hit rate chart
            if (tierHitChart) {
                const totalHits = Object.values(memoryTierStats).reduce((sum, tier) => sum + tier.hits, 0);
                const hitPercentages = [
                    (memoryTierStats.redis.hits / totalHits * 100) || 0,
                    (memoryTierStats.postgresql.hits / totalHits * 100) || 0,
                    (memoryTierStats.chromadb.hits / totalHits * 100) || 0
                ];
                
                tierHitChart.data.datasets[0].data = hitPercentages;
                tierHitChart.update();
            }
            
            // Update latency chart
            if (tierLatencyChart) {
                tierLatencyChart.data.datasets[0].data = [
                    memoryTierStats.redis.latency.toFixed(1),
                    memoryTierStats.postgresql.latency.toFixed(1),
                    memoryTierStats.chromadb.latency.toFixed(1)
                ];
                tierLatencyChart.update();
            }
            
            // Update stat cards
            document.getElementById('redis-hit-rate').textContent = 
                `${((memoryTierStats.redis.hits / memoryTierStats.redis.accesses * 100) || 0).toFixed(0)}%`;
            document.getElementById('redis-latency').textContent = 
                `${memoryTierStats.redis.latency.toFixed(0)}ms`;
            
            document.getElementById('pg-hit-rate').textContent = 
                `${((memoryTierStats.postgresql.hits / memoryTierStats.postgresql.accesses * 100) || 0).toFixed(0)}%`;
            document.getElementById('pg-latency').textContent = 
                `${memoryTierStats.postgresql.latency.toFixed(0)}ms`;
            
            document.getElementById('chroma-hit-rate').textContent = 
                `${((memoryTierStats.chromadb.hits / memoryTierStats.chromadb.accesses * 100) || 0).toFixed(0)}%`;
            document.getElementById('chroma-latency').textContent = 
                `${memoryTierStats.chromadb.latency.toFixed(0)}ms`;
        }
        
        function updateOptimizationSuggestions(suggestions) {
            const container = document.getElementById('optimization-list');
            container.innerHTML = '';
            
            suggestions.slice(0, 3).forEach(suggestion => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.innerHTML = `
                    <div class="suggestion-text">${suggestion.suggestion}</div>
                    <div class="suggestion-impact">
                        Pattern: "${suggestion.pattern}" • 
                        Potential savings: ${suggestion.potential_savings_ms}ms per query
                    </div>
                `;
                container.appendChild(item);
            });
        }
        
        function updateKnowledgeAccess(event) {
            const query = event.payload.query || 'general';
            knowledgeAccess[query] = (knowledgeAccess[query] || 0) + 1;
            
            // Update heatmap
            const grid = document.getElementById('knowledge-grid');
            grid.innerHTML = '';
            
            Object.entries(knowledgeAccess)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20)
                .forEach(([item, count]) => {
                    const cell = document.createElement('div');
                    cell.className = 'heatmap-cell';
                    
                    if (count > 10) cell.classList.add('hot');
                    else if (count > 5) cell.classList.add('warm');
                    else cell.classList.add('cool');
                    
                    cell.innerHTML = `
                        <div>${item.substring(0, 10)}</div>
                        <div style="font-size: 16px; margin-top: 4px;">${count}</div>
                    `;
                    
                    grid.appendChild(cell);
                });
        }
        
        function updateTokenUsage(event) {
            if (event.payload.tokens_used || event.payload.cost) {
                const agentId = event.source_agent?.id || 'system';
                if (!agentCosts[agentId]) {
                    agentCosts[agentId] = { tokens: 0, cost: 0 };
                }
                
                agentCosts[agentId].tokens += event.payload.tokens_used || 0;
                agentCosts[agentId].cost += event.payload.cost || event.payload.estimated_cost || 0;
                
                // Update display
                const container = document.getElementById('agent-costs');
                container.innerHTML = '';
                
                Object.entries(agentCosts)
                    .sort((a, b) => b[1].cost - a[1].cost)
                    .forEach(([agent, data]) => {
                        const item = document.createElement('div');
                        item.className = 'cost-item';
                        item.innerHTML = `
                            <span>${agent}</span>
                            <span>${data.tokens.toLocaleString()} tokens ($${data.cost.toFixed(3)})</span>
                        `;
                        container.appendChild(item);
                    });
                
                // Update total cost
                const totalCost = Object.values(agentCosts).reduce((sum, data) => sum + data.cost, 0);
                document.getElementById('cost-today').textContent = `$${totalCost.toFixed(2)}`;
            }
        }
        
        function updateCollaborationGraph(event) {
            // This would update a network visualization
            // For now, just log it
            console.log('Collaboration event:', event.payload);
        }
        
        function updateMetrics(event) {
            // Update various sidebar metrics based on events
            if (event.performance_metrics) {
                const latency = event.performance_metrics.latency_ms;
                const currentAvg = parseFloat(document.getElementById('response-time').textContent);
                const newAvg = (currentAvg * 0.9 + latency * 0.1) / 1000; // Simple moving average
                document.getElementById('response-time').textContent = `${newAvg.toFixed(1)}s`;
            }
        }
        
        function updatePerformanceMetrics(metrics) {
            if (!metrics) return;
            
            // Update performance overview
            if (metrics.throughput) {
                performanceMetrics.throughput = metrics.throughput.events_per_second || 0;
                document.getElementById('throughput-value').textContent = performanceMetrics.throughput.toFixed(1);
            }
            
            if (metrics.batching) {
                performanceMetrics.batchingEfficiency = metrics.batching.efficiency || 0;
                performanceMetrics.currentBatchSize = metrics.batching.current_batch_size || 0;
                performanceMetrics.totalBatches = metrics.batching.total_batches || 0;
                performanceMetrics.avgBatchSize = metrics.batching.avg_batch_size || 0;
                
                document.getElementById('batch-efficiency').textContent = `${performanceMetrics.batchingEfficiency.toFixed(0)}%`;
                document.getElementById('current-batch-size').textContent = performanceMetrics.currentBatchSize;
                document.getElementById('total-batches').textContent = performanceMetrics.totalBatches;
                document.getElementById('avg-batch-size').textContent = performanceMetrics.avgBatchSize.toFixed(1);
            }
            
            if (metrics.circuit_breaker) {
                performanceMetrics.circuitState = metrics.circuit_breaker.state || 'closed';
                const circuitElement = document.getElementById('circuit-state');
                circuitElement.textContent = performanceMetrics.circuitState.toUpperCase();
                circuitElement.className = `circuit-state ${performanceMetrics.circuitState.toUpperCase()}`;
                document.getElementById('circuit-trips').textContent = `${metrics.circuit_breaker.trip_count || 0} trips`;
            }
            
            if (metrics.throughput) {
                performanceMetrics.dropRate = metrics.throughput.drop_rate || 0;
                document.getElementById('drop-rate').textContent = `${performanceMetrics.dropRate.toFixed(1)}%`;
            }
            
            if (metrics.latency) {
                performanceMetrics.avgLatency = metrics.latency.avg_ms || 0;
                performanceMetrics.p95Latency = metrics.latency.p95_ms || 0;
                performanceMetrics.p99Latency = metrics.latency.p99_ms || 0;
                
                updateLatencyBars();
            }
            
            // Update charts if visible
            if (document.getElementById('performance-view').style.display !== 'none') {
                updatePerformanceCharts();
            }
        }
        
        function updateLatencyBars() {
            const maxLatency = Math.max(performanceMetrics.p99Latency, 200);
            
            // Update values
            document.getElementById('avg-latency').textContent = `${performanceMetrics.avgLatency.toFixed(0)}ms`;
            document.getElementById('p95-latency').textContent = `${performanceMetrics.p95Latency.toFixed(0)}ms`;
            document.getElementById('p99-latency').textContent = `${performanceMetrics.p99Latency.toFixed(0)}ms`;
            
            // Update bar widths
            document.getElementById('avg-latency-bar').style.width = `${(performanceMetrics.avgLatency / maxLatency * 100)}%`;
            document.getElementById('p95-latency-bar').style.width = `${(performanceMetrics.p95Latency / maxLatency * 100)}%`;
            document.getElementById('p99-latency-bar').style.width = `${(performanceMetrics.p99Latency / maxLatency * 100)}%`;
        }
        
        function initializePerformanceCharts() {
            // Initialize Batch Size Chart
            const batchCtx = document.getElementById('batch-size-chart').getContext('2d');
            batchSizeChart = new Chart(batchCtx, {
                type: 'line',
                data: {
                    labels: Array(20).fill(''),
                    datasets: [{
                        label: 'Batch Size',
                        data: Array(20).fill(0),
                        borderColor: '#00ff88',
                        backgroundColor: 'rgba(0, 255, 136, 0.1)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 60,
                            grid: { color: '#333' },
                            ticks: { color: '#fff' }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { display: false }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
            
            // Initialize Latency Chart
            const latencyCtx = document.getElementById('latency-chart').getContext('2d');
            latencyPercentilesChart = new Chart(latencyCtx, {
                type: 'bar',
                data: {
                    labels: ['Avg', 'P95', 'P99'],
                    datasets: [{
                        label: 'Latency (ms)',
                        data: [0, 0, 0],
                        backgroundColor: ['#00ff88', '#0088ff', '#ff6b6b']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: '#333' },
                            ticks: { color: '#fff' }
                        },
                        x: {
                            grid: { color: '#333' },
                            ticks: { color: '#fff' }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }
        
        function updatePerformanceCharts() {
            // Update batch size chart with rolling data
            if (batchSizeChart) {
                const currentData = batchSizeChart.data.datasets[0].data;
                currentData.push(performanceMetrics.currentBatchSize);
                if (currentData.length > 20) {
                    currentData.shift();
                }
                batchSizeChart.update();
            }
            
            // Update latency chart
            if (latencyPercentilesChart) {
                latencyPercentilesChart.data.datasets[0].data = [
                    performanceMetrics.avgLatency,
                    performanceMetrics.p95Latency,
                    performanceMetrics.p99Latency
                ];
                latencyPercentilesChart.update();
            }
        }
        
        function switchView(view) {
            // Hide all views
            document.querySelectorAll('.content > div').forEach(el => {
                el.style.display = 'none';
            });
            
            // Show selected view
            document.getElementById(`${view}-view`).style.display = 'block';
            
            // Update active button
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Initialize charts if switching to memory view
            if (view === 'memory' && !tierHitChart) {
                setTimeout(initializeMemoryCharts, 100);
            }
            
            // Initialize charts if switching to performance view
            if (view === 'performance' && !batchSizeChart) {
                setTimeout(initializePerformanceCharts, 100);
            }
        }
        
        // Initialize WebSocket connection
        connectWebSocket();
        
        // Simulate some initial memory tier data for demo
        setTimeout(() => {
            const demoMemoryEvents = [
                {
                    event_type: 'memory_tier_access',
                    source_agent: { id: 'neuroscientist' },
                    payload: {
                        tier_accessed: 'redis',
                        total_latency_ms: 5.2,
                        tier_latencies: {
                            redis: { latency_ms: 5.2, hit: true, items_found: 3 }
                        },
                        cache_hit: true,
                        query_type: 'biometric'
                    },
                    timestamp: new Date().toISOString()
                },
                {
                    event_type: 'memory_tier_access',
                    source_agent: { id: 'training_agent' },
                    payload: {
                        tier_accessed: 'postgresql',
                        total_latency_ms: 32.5,
                        tier_latencies: {
                            redis: { latency_ms: 4.8, hit: false, items_found: 0 },
                            postgresql: { latency_ms: 27.7, hit: true, items_found: 5 }
                        },
                        cache_hit: false,
                        query_type: 'historical'
                    },
                    timestamp: new Date().toISOString()
                },
                {
                    event_type: 'memory_tier_access',
                    source_agent: { id: 'neuroscientist' },
                    payload: {
                        tier_accessed: 'chromadb',
                        total_latency_ms: 187.3,
                        tier_latencies: {
                            redis: { latency_ms: 5.1, hit: false, items_found: 0 },
                            postgresql: { latency_ms: 26.2, hit: false, items_found: 0 },
                            chromadb: { latency_ms: 156.0, hit: true, items_found: 8 }
                        },
                        cache_hit: false,
                        query_type: 'analytical',
                        optimization_suggestions: [
                            {
                                suggestion: 'Pre-cache this query pattern in Redis',
                                pattern: 'complex analytical query',
                                potential_savings_ms: 182
                            }
                        ]
                    },
                    timestamp: new Date().toISOString()
                }
            ];
            
            demoMemoryEvents.forEach(event => {
                handleRealtimeEvent({ type: 'stream_event', event });
            });
            
            // Simulate performance metrics
            const demoPerformanceMetrics = {
                type: 'performance_metrics',
                timestamp: new Date().toISOString(),
                data: {
                    throughput: {
                        events_per_second: 856.3,
                        events_dropped: 12,
                        drop_rate: 0.3
                    },
                    batching: {
                        current_batch_size: 23,
                        efficiency: 82.5,
                        avg_batch_size: 41.2,
                        total_batches: 245
                    },
                    circuit_breaker: {
                        state: 'closed',
                        failure_rate: 2.1,
                        trip_count: 0,
                        uptime_seconds: 3821
                    },
                    latency: {
                        avg_ms: 42.3,
                        p95_ms: 98.5,
                        p99_ms: 156.2
                    }
                }
            };
            
            handleRealtimeEvent(demoPerformanceMetrics);
        }, 1000);
    </script>
</body>
</html> 